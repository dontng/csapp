预备分析 systrace

    线程状态查看
        (systrace 会用不同的颜色来标识不同的线程状态，每个方法上都会有对应的线程状态来标识目前线程所处的状态)
        通过查看线程状态进行分析，是 CPU 执行慢，还是 Binder 调用，又或是进行 IO 操作，还是拿不到 CPU 时间片

        绿色：运行中
                只有这种状态的进程才可能在 CPU 上运行
                同一时间可能有多个进程出于可执行状态，这些进程的 task_struct 结构 (进程控制块) 被放入对应 CPU 的可执行队列中
                (进程调度器的任务就是从各个 CPU 的可执行队列中分别选择一个进程在该 CPU 上运行)

                作用：查看 Running 状态的线程，查看其运行的时间，与竞品对比，分析原因
                /**
                 * 是否频率不够
                 * 是否跑在小核上
                 * 是否频繁在 Running 和 Runnable 之间切换，为什么
                 * 是否频繁在 Running 和 Sleep 之间切换，为什么
                 * 是否跑在不该跑的核上，比如不重要的线程占用超大核
                 */

        蓝色：可运行
                线程可运行但当前没有安排，在等待 CPU 调度

                作用：Runnable 状态的线程状态持续时间越长，则表示 CPU 的调度越忙，没有及时处理到该任务
                /**
                 * 是否后台有太多任务在跑
                 * 没有及时处理是因为频率太低
                 * 没有及时处理是因为被限制到某个 cpuset 里面，当时 CPU 很满
                 * 此时 Running 的任务是什么，为什么
                 */

        白色：休眠中
                线程没有工作要做，可能是因为线程在互斥锁上被阻塞

                作用：一般是在等事件驱动

        橘色：不可中断的睡眠态 IO Block
                线程在 IO 上阻塞或等待磁盘操作完成，一般底线都会标识出此时的 callsite: wait_on_page_locked_killable

                作用：一般表示 IO 操作慢，如果有大量的橘色不可中断的睡眠态出现，那一般是进入了低内存状态，
                申请内存的时候触发 pageFault，Linux系统的 page cache 链表中有时会出现一些没准备好的 page (即还没有把磁盘中的内容完全读出来)，
                而正好此时用户在访问这个 page 时就会出现 wait_on_page_locked_killable 阻塞
                只有系统当 IO 操作很繁忙时，每笔 IO 操作都需要等待排队时，极其容易出现且阻塞时间往往会比较长

        紫色：不可中断的睡眠态
                线程在另一个内核操作 (通常是内存管理) 上被阻塞

                作用：一般是陷入了内核态，有些时候下是正常的，有些时候下是不正常的，需要按照具体的情况去分析

    进程唤醒信息分析
        systrace 会标识出一个非常有用的信息，可以帮助进行跨进程调用相关的分析

        一个进程被唤醒的信息往往比较重要，一个常见的情况是